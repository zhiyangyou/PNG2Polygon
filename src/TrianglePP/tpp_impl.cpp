 /** 
   @file  tpp_impl.cpp 
   @brief The implementation of the Delaunay class and iterators of the Triangle++ wrapper

   The Delaunay class and its iterators wrap the J.R. Shevchuk's original C code of Triangle package (aka TriLib).

   @author  Marek Krajewski (mrkkrj), www.ib-krajewski.de / others (@see tpp_interface.hpp)
 */

// configuaration of the Triangle.h (i.e. TriLib's code):
#define NO_TIMER
#define DREDUCED
#define ANSI_DECLARATORS
#define TRILIBRARY
#define TRILIB_EXIT_BY_EXCEPTION
#define TRIFILES_OUTPUT_SUPPORT
#define TRIFILES_READ_SUPPORT
//#define CDT_ONLY // no, we want all algorithms!

#ifndef TRIANGLE_NO_TRILIB_SELFCHECK
// self-debug for TriLib - it will check and throw exceptions instead of crashing/looping endelessly!
#  define SELF_CHECK 
#endif

#ifndef _WIN64
// the MS x64 compilers do not use FPU (as SSE is the default) thus no extended precision problems!
#  define CPU86
#endif

#ifndef _WIN32
#define LINUX
#undef CPU86
#endif

// trace support:
//#define TRIANGLE_DBG_TO_FILE 1
//#undef TRIANGLE_DBG_TO_FILE // TEST:::

#include "tpp_trace.hpp"

// 1. wrapped library (TriLib)
#include "triangle_impl.hpp"

// 2. the wrapper itself (TrianglePP)
#include "tpp_interface.hpp"

#include <iostream>
#include <sstream>
#include <algorithm>

// helper macros
#include "tpp_triangle_macros.hpp"


// custom specialization of std::hash for Delaunay::Points
namespace std 
{
    template <>
    struct hash<tpp::Delaunay::Point>
    {
        std::size_t operator()(const tpp::Delaunay::Point& p) const
        {
            std::size_t h1 = std::hash<double>{}(p[0]);
            std::size_t h2 = std::hash<double>{}(p[1]);
            return h1 ^ (h2 << 1); // combine hashes
        }
    };
}


namespace tpp {

   // trace support
   FILE* g_debugFile = nullptr;  // OPEN TODO:: decouple, move to separate file!
   std::string g_debugFileName;  // dito

   // impl. constant
   const char* c_trppFileComment =  "\n# Generated by Triangle++" ;


// public methods

Delaunay::Delaunay(const std::vector<Point>& points, bool enableMeshIndexing)
   : m_triangleWrap(nullptr),
     m_in(nullptr),
     m_pmesh(nullptr),
     m_pbehavior(nullptr),
     m_vorout(nullptr),
     m_triAlgorithm(DivideConquer),
     m_minAngle(0.0f),
     m_maxArea(0.0f),
     m_convexHullWithSegments(false),
     m_extraVertexAttr(enableMeshIndexing),
     m_triangulated(false)
{
   m_pointList.assign(points.begin(), points.end());
}


Delaunay::~Delaunay()
{
   freeTriangleDataStructs();
}


void Delaunay::Triangulate(bool quality, DebugOutputLevel traceLvl)
{
   std::string options = "nz";  // n: need neighbors, z: index from 0

   setQualityOptions(options, quality);
   setDebugLevelOption(options, traceLvl);

   invokeTriLib(options);
}


void Delaunay::TriangulateConf(bool quality, DebugOutputLevel traceLvl)
{
   std::string options = "nz";  // n: need neighbors, z: index from 0

   setQualityOptions(options, quality);
   options.append("D"); // conforming Delaunay!
   setDebugLevelOption(options, traceLvl);

   invokeTriLib(options);
}


void Delaunay::Tesselate(bool useConformingDelaunay, DebugOutputLevel traceLvl) 
{
   std::string options = "nz";  // n: need neighbors, z: index from 0
   setDebugLevelOption(options, traceLvl);

   // "If the triangulated domain is"
   //"  convex and has no holes, you can use -D switch to force Triangle to"
   //"  construct a conforming Delaunay triangulation instead of a CCDT, so the"
   //"  Voronoi diagram will be valid."

   //options.append("D"); // Voronoi precondition ??? not really!!!

   if (useConformingDelaunay)
   {
      options.append("D");
   }
   options.append("v"); // Voronoi

   invokeTriLib(options);

   // now use the triangulation for a Voronoi diagram
   TP_MESH_BEHAVIOR_WRAP();

   // OPEN TODO::: check those preconditions??
   if (tpmesh->holes != 0)
   {
       /* ............ */
   }

   m_vorout = new triangulateio;
   TP_VOROUT();

   tpvorout->numberofpoints = tpmesh->triangles.items;
   tpvorout->numberofpointattributes = tpmesh->nextras;
   tpvorout->numberofedges = tpmesh->edges;

   tpvorout->pointlist = nullptr;
   tpvorout->pointattributelist = nullptr;
   tpvorout->pointmarkerlist = nullptr;
   tpvorout->numberofsegments = 0;
   tpvorout->numberofholes = 0;
   tpvorout->numberofregions = 0;
   tpvorout->regionlist = nullptr;
   tpvorout->edgelist = nullptr;
   tpvorout->edgemarkerlist = nullptr;
   tpvorout->normlist = nullptr;

   pTriangleWrap->writevoronoi(
         tpmesh, tpbehavior,
         &tpvorout->pointlist, &tpvorout->pointattributelist,
         &tpvorout->pointmarkerlist, &tpvorout->edgelist,
         &tpvorout->edgemarkerlist, &tpvorout->normlist);
}


bool Delaunay::checkConstraints(bool& possible) const
{
   //"     If the minimum angle is 28.6"
   //"        degrees or smaller, Triangle is mathematically guaranteed to"
   //"        terminate (assuming infinite precision arithmetic--Triangle may"
   //"        fail to terminate if you run out of precision).  In practice,"
   //"        Triangle often succeeds for minimum angles up to 34 degrees.  For"
   //"        some meshes, however, you might need to reduce the minimum angle to"
   //"        avoid problems associated with insufficient floating-point"
   //"        precision."
   if (m_minAngle <= 28.6f)
   {
      return true;
   }
   else
   {
      possible = (m_minAngle <= 34.0f);
      return false;
   }   
}


bool Delaunay::checkConstraintsOpt(bool relaxed) const
{
   bool possible = false;
   bool ret = checkConstraints(possible);

   if (!ret && relaxed)
   {
      return possible;
   }
   else
   {
      return ret;
   }
}


void Delaunay::getMinAngleBoundaries(float& guaranteed, float& possible)
{
   // see above:
   guaranteed = 28.6f;
   possible = 34.0f;
}


void Delaunay::setQualityConstraints(float angle, float area)
{
   setMinAngle(angle);
   setMaxArea(area);
}


bool Delaunay::setSegmentConstraint(const std::vector<Point>& segments)
{
   m_segmentList.clear();
   m_segmentList.reserve(segments.size());

   // OPEN TODO::: optimize - unquadrat it...
   for (size_t i = 0; i < segments.size(); ++i)
   {
      const std::vector<Point>::iterator it = std::find(m_pointList.begin(), m_pointList.end(), segments[i]);
      if (it == m_pointList.end())
      {
         m_segmentList.clear();
         return false;
      }
      else
      {
         m_segmentList.push_back(std::distance(m_pointList.begin(), it));  // OPEN TODO:: warning !!!
      }
   }

   // OPEN TODO::: check for intersections ???
   //  - seems to be not needed, re-read what the documentiation of TriLibrary says!!!!

   return true;
}


bool Delaunay::setSegmentConstraint(const std::vector<int>& segmentPointIndexes, DebugOutputLevel traceLvl)
{
   m_segmentList.clear();
   m_segmentList.reserve(segmentPointIndexes.size());

   for (size_t i = 0; i < segmentPointIndexes.size(); ++i)
   {      
      const int& pointIdx = segmentPointIndexes[i];
      if (pointIdx < 0 ||
          unsigned(pointIdx) >= m_pointList.size())
      {
         m_segmentList.clear();
         return false;
      }
      else
      {
         m_segmentList.push_back(pointIdx);
      }
   }

   // OPEN TODO::: check for intersections ???
   //  - seems to be not needed (???), re-read what the documentiation of TriLibrary says!!!!

   // sanitize inputs
   std::unordered_map<int, int> duplicates = checkForDuplicatePoints();

   if (!duplicates.empty())
   {
       sanitizeInputData(duplicates, traceLvl);
   }

   return true;
}


void Delaunay::enableMeshIndexGeneration() 
{
   m_extraVertexAttr = true;
}


void Delaunay::setAlgorithm(AlgorithmType alg)
{
   m_triAlgorithm = alg;
}


void Delaunay::useConvexHullWithSegments(bool useConvexHull)
{
#if 0
    // --> Yejneshwar commented on 26 Feb 22
    //Hi,
    //    Thank you for this implementation.
    //    could you please add support for the D tag ?
    //    i.e.remove concavities
    //
    //    EDIT :
    //    I have fixed the issue, will be submitting a pull request soon.
    //    Support for it existed but internally the "c" tag would still be added which caused the concavities to not be removed.

    TriangulateConf(options); //created a new function just for the -D tag, because the -c tag doesn't remove concavities with a boundary defined through the segment list.
#endif

    m_convexHullWithSegments = useConvexHull; // with/without convex hull (credits Yejneshwar!)
}


bool Delaunay::setHolesConstraint(const std::vector<Point>& holes)
{
   m_holesList = holes;

   // OPEN TODO::: check the intersection constraints ... ???

   return true;
}


bool Delaunay::setRegionsConstraint(const std::vector<Point>& regions, const std::vector<float>& areas)
{
   if (regions.size() != areas.size())
   {
      return false;
   }

   m_regionsConstrList.clear();
    
   for (size_t i = 0; i < regions.size(); ++i)
   {
      auto& r = regions[i];
      double arr[] = { r[0], r[1], areas[i], areas[i] }; // if no region attr - copy the area therein
      m_regionsConstrList.emplace_back(Point4(arr));
   }

   return true;
}


bool Delaunay::setRegionsConstraint(const std::vector<Point4>& regionConstr)
{
   m_regionsConstrList = regionConstr;
   return true; // OPEN TODO::: check something?
}


void Delaunay::writeoff(std::string& fname)
{
    if(!m_triangulated)
    {
        std::cerr << "ERROR: Write called before triangulation!";
        throw std::runtime_error("Write called before triangulation");
    }

    TP_MESH_BEHAVIOR_WRAP();

    char *pfname = new char[fname.size()+1];
    strcpy(pfname , fname.c_str());

    pTriangleWrap->writeoff(tpmesh, tpbehavior, pfname, 0, nullptr);
    delete [] pfname;
}


bool Delaunay::savePoints(const std::string& filePath)
{          
   if (!m_triangulated) 
   {
     struct triangulateio input;
     triangulateio* pin = (struct triangulateio *)&input;
    
     initTriangleInputData(pin, m_pointList);

     if (!m_triangleWrap)
     {
        Assert(!m_pmesh && !m_pbehavior, "");
        initTriangleDataForPoints();
     }

     TP_MESH_BEHAVIOR_WRAP();

     pTriangleWrap->transfernodes(
                tpmesh, tpbehavior, pin->pointlist, 
                pin->pointattributelist,
                pin->pointmarkerlist, pin->numberofpoints,
                pin->numberofpointattributes);
   }

   TP_MESH_BEHAVIOR_WRAP();
   const char* comments[] = { c_trppFileComment };
       
   pTriangleWrap->writenodes2file(tpmesh, tpbehavior, const_cast<char*>(filePath.c_str()),
                                  sizeof(comments)/sizeof(const char*), 
                                  const_cast<char**>(comments));
   return true;
}


bool Delaunay::saveSegments(const std::string& filePath)
{
   if (m_holesList.empty())
   {
      if (!m_triangulated)
      {
         // must triangulate for writenodes2file() etc to work
         Triangulate();
      }
   }
   else 
   {
      // re-triangualte w/o holes (as not to infect segments!!!)
      auto holes = m_holesList;
      m_holesList.clear();

      Triangulate();

      m_holesList = holes;

      TP_INPUT();
      pin->numberofholes = (int)m_holesList.size();
      pin->holelist = static_cast<double*>((void*)(&m_holesList[0]));
   }

   TP_MESH_BEHAVIOR_WRAP();

   // first write nodes
   char* polyfileName = const_cast<char*>(filePath.c_str());
   pTriangleWrap->writenodes2file(tpmesh, tpbehavior, polyfileName, 0, nullptr);

   // OPEN TODO:::: regions support???
   int numberofregions = 0;
   double* regionlist = nullptr;

   // holes?
   int numberofholes = 0;
   double* holelist = nullptr;

   if (!m_holesList.empty())
   {
       numberofholes = (int)m_holesList.size();
       holelist = static_cast<double*>((void*)(&m_holesList[0]));
   }

    bool append = true; // write into a single file!
    const char* comments[] = { c_trppFileComment };

    pTriangleWrap->writepoly2file(tpmesh, tpbehavior, polyfileName,
                                  holelist, numberofholes, regionlist, numberofregions,
                                  append,
                                  sizeof(comments)/sizeof(const char*), 
                                  const_cast<char**>(comments));

    return true;
}


bool Delaunay::readPoints(const std::string& filePath, std::vector<Delaunay::Point>& points)
{  
    if (!m_triangleWrap)
    {
       Assert(!m_pmesh && !m_pbehavior, "");
       initTriangleDataForPoints();
    }

    TP_MESH_BEHAVIOR_WRAP();

    tpbehavior->poly = 0; // poly file not provided!
    tpbehavior->usesegments = 0;
    FILE* polyfile = nullptr;
    char* polyfileName = nullptr; // no poly file!

    pTriangleWrap->readnodes(tpmesh, tpbehavior, const_cast<char*>(filePath.c_str()), polyfileName, &polyfile);

    // read points from the mesh data
    readPointsFromMesh(m_pointList);
       
    points = m_pointList; // OPEN TODO::: make optional parameter?????
    return true;
}


bool Delaunay::readSegments(
        const std::string& filePath,
        std::vector<Delaunay::Point>& points,
        std::vector<int>& segmentEndpoints,
        std::vector<Delaunay::Point>& holeMarkers,
        std::vector<Point4>& regionConstr)
{
    if (!m_triangleWrap)
    {
       Assert(!m_pmesh && !m_pbehavior, "");
       initTriangleDataForPoints();
    }

    TP_MESH_BEHAVIOR_WRAP();

    tpbehavior->poly = 1; // poly file provided!
    tpbehavior->usesegments = 1;   

    tpmesh->steinerleft = tpbehavior->steiner;

    FILE* polyfile = nullptr;
    char* polyfileName = const_cast<char*>(filePath.c_str());
    pTriangleWrap->readnodes(tpmesh, tpbehavior, nullptr, polyfileName, &polyfile);

    // get points from the mesh data
    readPointsFromMesh(m_pointList);
    points = m_pointList; // OPEN TODO::: make it optional param????

    auto duplicates = checkForDuplicatePoints();
    if (!duplicates.empty())
    {
        // read file directly
        //  - Trilib's code doesn't support duplicate points!
        if (!readSegmentsFromFile(polyfileName, polyfile, m_segmentList))
        {
            fclose(polyfile);
            return false;
        }

        // rebase to start with 0
        if (tpbehavior->firstnumber != 0)
        {
            for (auto& index : m_segmentList)
            {
                index -= tpbehavior->firstnumber;
                Assert(index >= 0, "");
            }
        }

        sanitizeInputData(duplicates); 

        points = m_pointList; // OPEN TODO::: make it optional param????
        segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
    }
    else
    {
#if 0 // OPEN TODO::: not working (on Windows!), mysterious file reading problems!!! :-O
        // triangulate to ensure formskeleton() will read segments!
        tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

        // Ensure that no vertex can be mistaken for a triangular bounding box
        // vertex in insertvertex()!
        tpmesh->infvertex1 = nullptr;
        tpmesh->infvertex2 = nullptr;
        tpmesh->infvertex3 = nullptr;

        tpmesh->checksegments = 1;

        // no holes yet:
        tpmesh->holes = 0;
        tpmesh->regions = 0;

        pTriangleWrap->formskeleton4file(tpmesh, tpbehavior, polyfile, polyfileName);

        // get segments from the mesh data
        readSegmentsFromMesh(m_segmentList);
#else
        if (!readSegmentsFromFile(polyfileName, polyfile, m_segmentList))
        {
           fclose(polyfile);
           return false;
        }
#endif

        // rebase to start with 0
        if (tpbehavior->firstnumber != 0)
        {
            for (auto& index : m_segmentList)
            {
                index -= tpbehavior->firstnumber;
            }
        }

        segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
    }

    // get hole marker points
    readHolesFromFile(polyfileName, polyfile, m_holesList, m_regionsConstrList);

    holeMarkers = m_holesList;      // OPEN TODO::: make it optional param????
    regionConstr = m_regionsConstrList;   // OPEN TODO::: make it optional param????

    // ready
    fclose(polyfile);
    return true;
}


void Delaunay::enableFileIOTrace(bool enable)
{
   if (enable)
   {
      INIT_TRACE("tpp_fileIO.out.txt");
      TRACE("File IO trace: \n");
   }
   else
   {
      END_TRACE("tpp_fileIO.out.txt");
   }
}


int Delaunay::edgeCount() const
{
    return TP_MESH_PTR()->edges;
}


int Delaunay::triangleCount() const
{
    return TP_MESH_PTR()->triangles.items;
}


int Delaunay::verticeCount() const
{
    TP_MESH_BEHAVIOR();
    int outvertices;

    if (tpbehavior->jettison) 
    {
        outvertices = tpmesh->vertices.items - tpmesh->undeads;
    } 
    else 
    {
        outvertices = tpmesh->vertices.items;
    }

    return outvertices;
}


int Delaunay::hullSize() const
{
   return TP_MESH_PTR()->hullsize;
}


int Delaunay::voronoiEdgeCount() const
{
   TP_VOROUT();

   return
      !tpvorout ? 0 : tpvorout->numberofedges;
}


int Delaunay::voronoiPointCount() const
{
   TP_VOROUT();

   return
      !tpvorout ? 0 : tpvorout->numberofpoints;
}


int Delaunay::holeCount() const
{
    return TP_MESH_PTR()->holes;
}


bool Delaunay::hasTriangulation() const
{
    return m_triangulated;
}


FaceIterator Delaunay::fbegin()
{
   return FaceIterator(this);
}


FaceIterator Delaunay::fend()
{
   FaceIterator fit;
   fit.floop.tri = (double***) nullptr;
   return fit;
}


FacesList Delaunay::faces()
{ 
   return FacesList(this);
};


FaceIterator FacesList::begin()
{
   return m_delaunay->fbegin();
}


FaceIterator FacesList::end()
{
   return m_delaunay->fend();
}


VertexIterator Delaunay::vbegin()
{
   return VertexIterator(this);
}


VertexIterator Delaunay::vend()
{
   VertexIterator vit;
   vit.vloop = ((Triwrap::vertex) nullptr);
   return vit;
}


VertexList Delaunay::vertices()
{
   return VertexList(this);
};


VertexList::VertexListIterator VertexList::begin()
{
   return m_delaunay->vbegin();
}


VertexList::VertexListIterator VertexList::end()
{
   return m_delaunay->vend();
}


VoronoiVertexIterator Delaunay::vvbegin()
{
   return VoronoiVertexIterator(this);
}


VoronoiVertexIterator Delaunay::vvend()
{
   VoronoiVertexIterator vvit;

   vvit.vvloop = nullptr;
   vvit.vvindex = 0;
   vvit.vvcount = 0;
   vvit.m_delaunay = nullptr;

   return vvit;
}


VoronoiEdgeIterator Delaunay::vebegin()
{
   return VoronoiEdgeIterator(this);
}


VoronoiEdgeIterator Delaunay::veend()
{
   VoronoiEdgeIterator veit;

   veit.veloop = nullptr;
   veit.veindex = 0;
   veit.vecount = 0;
   veit.m_delaunay = nullptr;

   return veit;
}


void Delaunay::getMinMaxPoints(double& minX, double& minY, double& maxX, double& maxY) const
{
    TP_MESH();

    minX = tpmesh->xmin;
    minY = tpmesh->ymin;
    maxX = tpmesh->xmax;
    maxY = tpmesh->ymax;
}


const Delaunay::Point& Delaunay::pointAtVertexId(int i) const
{
    Assert((i >= 0) && (unsigned(i) < m_pointList.size()), "Point index out of bounds!");

    return m_pointList[i];
}


TriangulationMesh Delaunay::mesh()
{
   return TriangulationMesh(this);
}


bool Delaunay::OrderPoints::operator() (const Point& lhs, const Point& rhs) const
{
   // first sort on X, then on Y coordinates!

   if (lhs[0] < rhs[0])
   {
      return true;
   }

   if (lhs[0] == rhs[0] && lhs[1] < rhs[1])
   {
      return true;
   }

   return false;
}


// private methods

void Delaunay::invokeTriLib(std::string& triswitches)
{
   INIT_TRACE("triangle.out.txt");
   TRACE("Triangulate ->");

   if (m_triangulated)
   {
      freeTriangleDataStructs();
   }

   m_in = new triangulateio;
   TP_INPUT();
   
   initTriangleInputData(pin, m_pointList);

   if (!m_segmentList.empty()) // OPEN:: a separate option to enable segment constraitns???
   {
      pin->numberofsegments = (int)m_segmentList.size() / 2;
      pin->segmentlist = m_segmentList.data();
      pin->segmentmarkerlist = nullptr;

      triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
      triswitches.append("B"); // but no boundary info at the moment!

      if (m_convexHullWithSegments)
      {
         triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boudnaries in carveholes())  
                                  //   --> Note: refining not supported yet!
                                  // If you are refining a mesh, this switch works differently; it generates the set of
                                  // boundary edges of the mesh, including boundaries of holes. 
      }
   }

   if (!m_holesList.empty())
   {
      pin->numberofholes = (int)m_holesList.size();
      pin->holelist = static_cast<double*>((void*)(&m_holesList[0]));

      if (m_segmentList.empty())
      {
         triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
         triswitches.append("B"); // but no boundary info at the moment!

         if (m_convexHullWithSegments)
         {
            triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boundaries in carveholes())
         }
      }
   }
  
   if (!m_regionsConstrList.empty() && triswitches.find("q") != std::string::npos)
   {
      pin->numberofregions = (int)m_regionsConstrList.size();
      pin->regionlist = static_cast<double*>((void*)(&m_regionsConstrList[0]));
      triswitches.append("a");
   }

   TRACE2s(" -- switches:", triswitches.c_str());

   // parse the options:
   triswitches.push_back('\0');
   char* pTriswitches = &triswitches[0];

   m_pmesh = new Triwrap::__pmesh;
   m_pbehavior = new Triwrap::__pbehavior;
   m_triangleWrap = new Triwrap;

   TP_MESH_BEHAVIOR_WRAP();

   pTriangleWrap->parsecommandline(1, &pTriswitches, tpbehavior);

   // initialize data structs
   pTriangleWrap->triangleinit(tpmesh);
   tpmesh->steinerleft = tpbehavior->steiner;

   pTriangleWrap->transfernodes(
         tpmesh, tpbehavior, pin->pointlist,
         pin->pointattributelist,
         pin->pointmarkerlist, pin->numberofpoints,
         pin->numberofpointattributes);

   // MAIN work: triangulate!
   tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

   // OPEN TODO:: 
   //    if(concave hull) - compute concave hull with the chi-algorithm,
   //                     - use it as segments in formskeleton()!!

   // Ensure that no vertex can be mistaken for a triangular bounding box 
   // vertex in insertvertex()!
   tpmesh->infvertex1 = nullptr;
   tpmesh->infvertex2 = nullptr;
   tpmesh->infvertex3 = nullptr;

   // support for the "-q" option
   if (tpbehavior->usesegments && (tpmesh->triangles.items > 0))
   {
      tpmesh->checksegments = 1;

      if (!tpbehavior->refine)
      {
         // Insert PSLG segments and/or convex hull segments.
         pTriangleWrap->formskeleton(tpmesh, tpbehavior, pin->segmentlist,
                                     pin->segmentmarkerlist, pin->numberofsegments);
      }
   }

   // carve out the holes before enforcing quality constr!
   if (tpbehavior->poly && (tpmesh->triangles.items > 0))
   {
      tpmesh->holes = pin->numberofholes;
      double* holelist = pin->holelist;

      tpmesh->regions = pin->numberofregions;
      double* regionlist = pin->regionlist; 

      if (!tpbehavior->refine)
      {
         // Carve out holes and concavities.
         pTriangleWrap->carveholes(tpmesh, tpbehavior, holelist, tpmesh->holes, regionlist, tpmesh->regions);
      }
   }

   if (tpbehavior->quality && (tpmesh->triangles.items > 0))
   {
      // Enforce angle and area constraints
      pTriangleWrap->enforcequality(tpmesh, tpbehavior);
   }

   // Calculate the number of edges.
   tpmesh->edges = (3l * tpmesh->triangles.items + tpmesh->hullsize) / 2l;

   pTriangleWrap->numbernodes(tpmesh, tpbehavior);
   TRACE2i("<- Triangulate: triangles= ", tpmesh->triangles.items);

   m_triangulated = true;
   END_TRACE("triangle.out.txt");
}


void Delaunay::setDebugLevelOption(std::string& options, DebugOutputLevel traceLvl)
{
   switch (traceLvl)
   {
   case None:
      options.append("Q"); // Q: no trace, no debug
      break;
   case Info:
      options.append("V"); // basic trace & debug
      break;
   case Vertex:
      options.append("VV"); // detailed trace & debug
      break;
   case Debug:
      options.append("VVVV"); // much, much more - too much?
      break;
   default:
       Assert(false, "unknown trace level");
   }
}


void Delaunay::setQualityOptions(std::string& options, bool quality)
{
    if (quality)
    {
        auto formatFloatConstraint = [](float f)
        {
            std::ostringstream ss;
            ss << f;
            return ss.str();
        };

        options.append("q");

        if (m_minAngle > 0)
        {
            options.append(formatFloatConstraint(m_minAngle));
        }

        if (m_maxArea > 0)
        {
            options.append("a" + formatFloatConstraint(m_maxArea));
        }
    }

    // TEST::: algorithm
    // OPEN TODO::: own method??? 
    //  -- or ditch the workaround with the option string altogether???

    switch (m_triAlgorithm)
    {
    case Incremental:
       options.append("i");
       break;

    case Sweepline:
       options.append("F");
       break;

    case DivideConquer:
       // it's the default!
       break;

    default:
       Assert(false, "unknown algorithm type");
    }
}


void Delaunay::freeTriangleDataStructs()
{
   if (m_in == nullptr && m_vorout == nullptr && 
       m_triangleWrap == nullptr && m_pmesh == nullptr &&
       m_pbehavior == nullptr)
   {
      return; // already freed!
   }

   //struct triangulateio* pin = (struct triangulateio*) m_in;

   TP_MESH_BEHAVIOR_WRAP();
   TP_INPUT();
   TP_VOROUT();

   pTriangleWrap->triangledeinit(tpmesh, tpbehavior);

   delete tpmesh;
   delete tpbehavior;
   delete pin;
   delete tpvorout;
   delete pTriangleWrap;

   m_in = nullptr;
   m_vorout = nullptr;
   m_triangleWrap = nullptr;
   m_pmesh = nullptr;
   m_pbehavior = nullptr;
}


void Delaunay::initTriangleDataForPoints()
{
    Assert(!m_triangleWrap && !m_pmesh && !m_pbehavior, "Expected empty instance!");

    m_triangleWrap = new Triwrap;
    m_pmesh = new Triwrap::__pmesh;
    m_pbehavior = new Triwrap::__pbehavior;

    TP_MESH_BEHAVIOR_WRAP();

    *tpmesh = {};  // OPEN TODO::: .............. {} too big for the stack, warning by VisualStudio!?
    *tpbehavior = {};

    // nonzero defaults:
    tpbehavior->firstnumber = 1;
    tpbehavior->dwyer = 1;
    tpbehavior->steiner = -1;
    tpbehavior->order = 1;
    tpbehavior->maxarea = -1.0;
    tpbehavior->quiet = 1;

    pTriangleWrap->triangleinit(tpmesh);
}


void Delaunay::initTriangleInputData(triangulateio* pin, const std::vector<Point>& points) /*const*/
{
    pin->numberofpoints = (int)points.size();
    pin->numberofpointattributes = m_extraVertexAttr ? 1 : 0;
    pin->pointlist = static_cast<double*>((void*)(&points[0]));

    if (m_extraVertexAttr)
    {       
       m_defaultExtraAttrs.clear();
       m_defaultExtraAttrs.insert(m_defaultExtraAttrs.begin(), points.size(), -1.0);

       pin->pointattributelist = static_cast<double*>((void*)(&m_defaultExtraAttrs[0]));
    }
    else
    {
       pin->pointattributelist = nullptr;
    }
    
    pin->pointmarkerlist = nullptr;
    pin->numberofsegments = 0;
    pin->numberofholes = 0;
    pin->numberofregions = 0;
    pin->regionlist = nullptr;
}


void Delaunay::sanitizeInputData(std::unordered_map<int, int> duplicatePointsMap, DebugOutputLevel traceLvl)
{
    // don't use duplicated points in segments
    //  - replace with "originals"
    for (size_t i = 0; i < m_segmentList.size(); ++i)
    {
        auto& pointIdx = m_segmentList[i];
        auto iter = duplicatePointsMap.find(pointIdx);

        if (iter != duplicatePointsMap.end())
        {
            TRACE2i(" -- sanitize: duplicate point as segment endpoint detected, index=", pointIdx);
            TRACE2i(" --           replaced with index=", iter->second);

            if (traceLvl != None)
            {
                printf("Warning:  segments[%zd] - a duplicate vertex (index=%d) replaced by original (index=%d).\n",
                    i / 2, pointIdx, iter->second);
            }

            pointIdx = iter->second;
        }
    }

    // remove point duplicates
    std::vector<int> duplicatePts(duplicatePointsMap.size());
    std::transform(duplicatePointsMap.begin(), duplicatePointsMap.end(), duplicatePts.begin(), [](auto& pair) { return pair.first; });
    std::sort(duplicatePts.begin(), duplicatePts.end());

    for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter)
    {
        m_pointList.erase(m_pointList.begin() + *iter);

        if (traceLvl != None)
        {
            printf("Warning:  A duplicate vertex point deleted at index=%d.\n", *iter);
        }
    }

    // corrections for removed points
    for (auto& pointIdx : m_segmentList)
    {
        int i = 0;
        for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter, ++i)
        {
            if (pointIdx > *iter)
            {
                if (traceLvl != None)
                {
                    printf("Warning:  Correction for segment endpoint - iter=%d pointIdx=%d, new_pointIdx=%zd.\n",
                        *iter, pointIdx, pointIdx - (duplicatePts.size() - i));
                }

                pointIdx -= (duplicatePts.size() - i);  // OPEN TODO:: warning !!!
                break;
            }
        }
    }
}


void Delaunay::readPointsFromMesh(std::vector<Point>& points) const
{
    TP_MESH_BEHAVIOR_WRAP();

    points.clear();
    points.reserve(tpmesh->invertices);

    int vertexnumber = tpbehavior->firstnumber;
    Triwrap::__pmesh* m = tpmesh; // needed for Triwrap's macros vertextype()/setvertexmark()

    pTriangleWrap->traversalinit(&tpmesh->vertices);
    Triwrap::vertex vertexloop = pTriangleWrap->vertextraverse(tpmesh);

    while (vertexloop != nullptr)
    {
        if (!tpbehavior->jettison || (vertextype(vertexloop) != UNDEADVERTEX))
        {
            /* X and Y coordinates. */
            points.push_back({ vertexloop[0], vertexloop[1] });

#if 0 // --> not yet supported!
            /* Vertex attributes. */
            for (i = 0; i < tpmesh->nextras; i++) {
                palist[attribindex++] = vertexloop[2 + i];
            }
            if (!tpbehavior->nobound) {
                /* Copy the boundary marker. */
                pmlist[vertexnumber - tpbehavior->firstnumber] = vertexmark(vertexloop);
            }
#endif
            setvertexmark(vertexloop, vertexnumber);
            vertexnumber++;
        }

        vertexloop = pTriangleWrap->vertextraverse(tpmesh);
    }
}


void Delaunay::readSegmentsFromMesh(std::vector<int>& segmentEndpoints) const
{
    TP_MESH_BEHAVIOR_WRAP();

    segmentEndpoints.clear();
    segmentEndpoints.reserve(tpmesh->insegments * 2);

    struct Triwrap::osub subsegloop;
    Triwrap::vertex endpoint1, endpoint2;
    long subsegnumber;

    pTriangleWrap->traversalinit(&tpmesh->subsegs);
    subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
    subsegloop.ssorient = 0;
    subsegnumber = tpbehavior->firstnumber;

    Triwrap::__pmesh* m = tpmesh;   // needed for Triwrap's macro vertexmark()
    typedef Triwrap::vertex vertex; // same!

    while (subsegloop.ss != nullptr)
    {
        sorg(subsegloop, endpoint1);
        sdest(subsegloop, endpoint2);

        // Copy indices of the segment's two endpoints
        segmentEndpoints.push_back(vertexmark(endpoint1));
        segmentEndpoints.push_back(vertexmark(endpoint2));

#if 0 // --> not yet supported!
        if (!b->nobound) {
            /* Copy the boundary marker. */
            smlist[subsegnumber - b->firstnumber] = mark(subsegloop);
        }
#endif

        subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
        subsegnumber++;
    }
}


void Delaunay::readHolesFromFile(
        char* polyfileName, 
        FILE* polyfile,
        std::vector<Point>& holeMarkers, 
        std::vector<Point4>& regionConstr) const
{
   TP_MESH_BEHAVIOR_WRAP();

   REAL* holearray = nullptr;
   REAL* regionarray = nullptr;

   holeMarkers.clear();

   // read also the regions!
   int regionattrib = tpbehavior->regionattrib;
   tpbehavior->regionattrib = 1;   
   int regionCt = -1;

   try
   {
      pTriangleWrap->readholes(tpmesh, tpbehavior, polyfile, polyfileName,
                               &holearray, &tpmesh->holes, &regionarray, &regionCt);
      tpmesh->regions = regionCt;
   }
   catch (...)
   {     
      // maybe no regions in file ???
      if (regionCt == -1)
      {
         tpmesh->regions = 0;
      }
      else
      {
         // real parsing problem
         throw;
      }      
   }

   tpbehavior->regionattrib = regionattrib;

   for (int i = 0; i < 2 * tpmesh->holes; i += 2)
   {
      holeMarkers.emplace_back(holearray[i], holearray[i + 1]);
   }

   if (tpmesh->holes > 0)
   {
      pTriangleWrap->trifree((VOID*)holearray);
   }

   regionConstr.clear();

   for (int i = 0; i < 4 * tpmesh->regions; i += 4)
   {
      double arr[] = { regionarray[i], regionarray[i + 1], regionarray[i + 2],  regionarray[i + 3] };
      regionConstr.emplace_back(arr);
   }

   if (tpmesh->regions > 0)
   {
      pTriangleWrap->trifree((VOID*)regionarray);
   }
}


std::unordered_map<int, int> Delaunay::checkForDuplicatePoints() const
{
    std::unordered_map<Delaunay::Point, size_t> uniqueMap;
    std::unordered_map<int, int> duplicateMap;

    for (size_t i = 0; i < m_pointList.size(); ++i)
    {
        auto& point = m_pointList[i];

        auto iter = uniqueMap.find(point);
        if (iter == uniqueMap.end())
        {
            uniqueMap.insert({ point, i });
        }
        else
        {
            duplicateMap.insert({ i, iter->second });  // OPEN TODO:: warning !!!
        }
    }

    return duplicateMap;    
}


bool Delaunay::readSegmentsFromFile(char* polyfileName, FILE* polyfile, std::vector<int>& segmentEndpoints)
{
    TRACE(" -> readSegmentsFromFile()");

    char inputline[INPUTLINESIZE];
    char* stringptr;
    int segmentmarkers;
    int end1, end2;
    int boundmarker;
    int i;

    TP_MESH_BEHAVIOR_WRAP();

    stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
    int insegments = (int)strtol(stringptr, &stringptr, 0);

    stringptr = pTriangleWrap->findfield(stringptr);
    segmentmarkers = (*stringptr == '\0') 
                        ? 0 : (int)strtol(stringptr, &stringptr, 0);
    boundmarker = 0;

    // Read and insert the segments.
    segmentEndpoints.clear();
    segmentEndpoints.reserve(tpmesh->insegments * 2);

    for (i = 0; i < /*m->*/insegments; i++)
    {
        stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
        stringptr = pTriangleWrap->findfield(stringptr);
        if (*stringptr == '\0') 
        {
            printf("Error:  Segment %d has no endpoints in %s.\n", 
                   tpbehavior->firstnumber + i, polyfileName);
            return false; 
        }
        else 
        {
            end1 = (int)strtol(stringptr, &stringptr, 0);
        }
        
        stringptr = pTriangleWrap->findfield(stringptr);
        if (*stringptr == '\0') 
        {
            printf("Error:  Segment %d is missing its second endpoint in %s.\n", 
                   tpbehavior->firstnumber + i, polyfileName);
            return false;
        }
        else 
        {
            end2 = (int)strtol(stringptr, &stringptr, 0);
        }

        if (segmentmarkers) 
        {
            stringptr = pTriangleWrap->findfield(stringptr);
            boundmarker = (*stringptr == '\0')
                             ? 0 : (int)strtol(stringptr, &stringptr, 0);
        }

        if ((end1 < tpbehavior->firstnumber) ||
            (end1 >= tpbehavior->firstnumber + tpmesh->invertices)) 
        {
            if (!tpbehavior->quiet) 
            {
                printf("Warning:  Invalid first endpoint of segment %d in %s.\n",
                       tpbehavior->firstnumber + i, polyfileName);
            }
        }
        else if ((end2 < tpbehavior->firstnumber) ||
                 (end2 >= tpbehavior->firstnumber + tpmesh->invertices)) 
        {
            if (!tpbehavior->quiet) 
            {
                printf("Warning:  Invalid second endpoint of segment %d in %s.\n",
                       tpbehavior->firstnumber + i, polyfileName);
            }
        }
        else 
        {
            // OPEN TODO:::  one last check? ????
#if 0
            /* Find the vertices numbered `end1' and `end2'. */
            Triwrap::vertex endpoint1 = pTriangleWrap->getvertex(m, b, end1);
            Triwrap::vertex endpoint2 = pTriangleWrap->getvertex(m, b, end2);
            if ((endpoint1[0] == endpoint2[0]) && (endpoint1[1] == endpoint2[1])) 
            {
                if (!tpbehavior->quiet) 
                {
                    printf("Warning:  Endpoints of segment %d are coincident in %s.\n",
                           b->firstnumber + i, polyfilename);
                }
            }
            else 
            {
                insertsegment(m, b, endpoint1, endpoint2, boundmarker);
            }
#endif
            segmentEndpoints.push_back(end1);
            segmentEndpoints.push_back(end2);
        }
    }

    return true;
}


void Delaunay::SetPoint(Point& point, /*Triwrap::vertex*/ double* vertexptr)
{
   // -- HACK:: double* as not to export internal impl.
   // OPEN TODO: compile test type check - Triwrap::vertex == double* ???

   point[0] = (vertexptr)[0];  // = x
   point[1] = (vertexptr)[1];  // = y
}


int Delaunay::GetFirstIndexNumber() const
{
   Triwrap::__pbehavior* pbehavior = (Triwrap::__pbehavior*)m_pbehavior;
   return pbehavior->firstnumber;
}


//  Iterators and Mesh methods

typedef Triwrap::vertex   vertex;
typedef Triwrap::triangle triangle;
typedef Triwrap::__otriangle trianglelooptype; // i.e. oriented triangle


///////////////////////////////
//
//  Face Iterator impl.
//
///////////////////////////////

FaceIterator::FaceIterator(Delaunay* triangulator)
   : m_delaunay(triangulator),
     meshPointCount(0)
{
   floop.tri = nullptr;

   TP_MESH_WRAP_ITER();
   TP_PLOOP_ITER();

   pTriangleWrap->traversalinit(&(tpmesh->triangles));

   ploop->tri = pTriangleWrap->triangletraverse(tpmesh);
   ploop->orient = 0;
}


FaceIterator& FaceIterator::operator++()
{
   // cout << "++ called\n";

   TP_MESH_WRAP_ITER();   
   TP_PLOOP_ITER();

   ploop->tri = pTriangleWrap->triangletraverse(tpmesh);

   // cout << "tri val = " << ploop->tri << endl;

   return *this;
}


FaceIterator FaceIterator::operator++(int)
{
   FaceIterator copy(*this);
   ++*this; 
   return copy;
}


bool FaceIterator::isGhost() const
{
   TP_MESH_ITER();
   TP_PLOOP_ITER();

   return (ploop->tri == tpmesh->dummytri);
}


bool FaceIterator::isdummy() const
{
   // deprected, will be removed!!!
   return isGhost();
}


bool FaceIterator::empty() const
{
   return floop.tri == nullptr;
}


bool FaceIterator::hasSteinerPoints() const
{
   return
      Org() == -1 ||
      Dest() == -1 ||
      Apex() == -1;
}


int FaceIterator::Org(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   org(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


int FaceIterator::Dest(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   dest(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


int FaceIterator::Apex(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   apex(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


void FaceIterator::Org(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   org(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


void FaceIterator::Dest(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   dest(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


void FaceIterator::Apex(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   apex(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


double FaceIterator::area() const
{
   Delaunay::Point torg, tdest, tapex;

   (void)Org(&torg);
   (void)Dest(&tdest);
   (void)Apex(&tapex);

   double dxod(torg[0] - tdest[0]);
   double dyod(torg[1] - tdest[1]);
   double dxda(tdest[0] - tapex[0]);
   double dyda(tdest[1] - tapex[1]);

   double area = 0.5 * (dxod * dyda - dyod * dxda);
   return area;
}


int FaceIterator::getVertexIndex(/*Triwrap::vertex*/ double* vertexptr) const
{
   // OPEN TODO: compile test type check - Triwrap::vertex == double* ???

   TP_MESH_ITER();
   TP_BEHAVIOR_ITER();

   int ret =
      (((int*)(vertexptr))[tpmesh->vertexmarkindex])
      -
      tpbehavior->firstnumber;

   return ((unsigned)ret < m_delaunay->m_pointList.size()) ? ret : -1;
}


int FaceIterator::getMeshVertexIndex(/*Triwrap::vertex*/ double* vertexptr) const
{
   if (!m_delaunay->m_extraVertexAttr)
   {
      std::cerr << "ERROR: Mesh indexing not enabled!\n";
      throw std::runtime_error("Mesh indexing not enabled");
   }

   Assert(meshPointCount >= 0, "");

   if (getVertexIndex(vertexptr) >= 0)
   {
      // extra attr. initialized to -1!
      if ((vertexptr)[2] < 0)
      {
         (vertexptr)[2] = meshPointCount++;
      }
   }
   else
   {
      // extra attr. initialized to -1!
      if ((vertexptr)[2] < 0)
      {
         Assert((vertexptr)[2] == -1.00, "");

         (vertexptr)[2] = meshPointCount++;
      }
   }

   int idx = (vertexptr)[2];  // OPEN TODO:: warning !!!
   Assert(idx >= 0, "");

   return idx;
}


bool operator==(FaceIterator const& fit1, FaceIterator const& fit2)
{
   return (fit1.floop.tri == fit2.floop.tri);
}


bool operator!=(FaceIterator const& fit1, FaceIterator const& fit2)
{
   return !(operator==(fit1, fit2));
}


bool operator<(FaceIterator const& fit1, FaceIterator const& fit2)
{
   return (fit1.floop.tri < fit2.floop.tri);
}


///////////////////////////////
//
//  Vertex Iterator impl.
//
///////////////////////////////

VertexIterator::VertexIterator(Delaunay* triangulator)
{
   m_delaunay = triangulator;

   TP_MESH_WRAP_ITER();
   TP_BEHAVIOR_ITER();

   pTriangleWrap->traversalinit(&(tpmesh->vertices));
   vloop = pTriangleWrap->vertextraverse(tpmesh);

   while
      (
         tpbehavior->jettison ||
         (
            ((int*)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX)
         )
   {
      vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);
   }
}


VertexIterator VertexIterator::operator++()
{
   TP_MESH_WRAP_ITER();
   TP_BEHAVIOR_ITER();

   while
      (
         tpbehavior->jettison ||
         (
            ((int*)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX)
         )
   {
      vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);
   }

   vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);

   VertexIterator vit;
   vit.vloop = vloop;
   vit.m_delaunay = m_delaunay;

   return vit;
}


int VertexIterator::vertexId() const
{
   TP_MESH_ITER();
   return ((int*)vloop)[tpmesh->vertexmarkindex];
}


double VertexIterator::x() const
{
   return ((Delaunay::Point*)vloop)->operator[](0);
}


double VertexIterator::y() const
{
   return ((Delaunay::Point*)vloop)->operator[](1);
}


Delaunay::Point& VertexIterator::operator*() const
{
   return *((Delaunay::Point*)vloop);
}


bool operator==(VertexIterator const& vit1, VertexIterator const& vit2)
{
   if (vit1.vloop == vit2.vloop) return true;
   return false;
}


bool operator!=(VertexIterator const& vit1, VertexIterator const& vit2)
{
   if (vit1.vloop != vit2.vloop) return true;
   return false;
}


/////////////////////////////////
//
//  Voronoi Point Iterator impl.
//
/////////////////////////////////

VoronoiVertexIterator::VoronoiVertexIterator()
   : m_delaunay(nullptr), 
     vvloop(nullptr), 
     vvindex(0), 
     vvcount(0) 
{
}


VoronoiVertexIterator::VoronoiVertexIterator(Delaunay* triangulator) 
{
   m_delaunay = triangulator;
   triangulateio* pvorout = (struct triangulateio*)triangulator->m_vorout;

   // TEST::: I hope so!
   Assert(triangulator->GetFirstIndexNumber() == 0, "");

   vvloop = pvorout->pointlist;
   vvindex = 0;
   vvcount = pvorout->numberofpoints;
}


VoronoiVertexIterator VoronoiVertexIterator::operator++() 
{
   VoronoiVertexIterator vit;

   vit.vvloop = vvloop;
   vit.vvindex = vvindex;
   vit.m_delaunay = m_delaunay;

   advance(1);
   return vit;
}


Delaunay::Point& VoronoiVertexIterator::operator*() const 
{
   Delaunay::Point::NT* pointlist = (Delaunay::Point::NT*)vvloop;

   // UB! -> but also in original code...  OPEN TODO::: !!!
   return *((Delaunay::Point*)(pointlist + vvindex));
}


void VoronoiVertexIterator::advance(int steps) 
{
   int stepSize = 2;
   Assert(Delaunay::Point().dim() == stepSize, "");

   if (vvindex/stepSize + steps < vvcount) 
   {
      vvindex += steps * stepSize;
   }
   else 
   {
      // at end
      vvindex = 0;
      vvloop = nullptr;
   }

   Assert(vvindex / stepSize < vvcount, "");
}


bool operator==(VoronoiVertexIterator const& lhs, VoronoiVertexIterator const& rhs) 
{
   if (lhs.vvloop == rhs.vvloop && lhs.vvindex == rhs.vvindex) 
      return true;

   return false;
}


bool operator!=(VoronoiVertexIterator const& lhs, VoronoiVertexIterator const& rhs) 
{
   return !(lhs == rhs);
}


/////////////////////////////////
//
//  Voronoi Edge Iterator impl.
//
/////////////////////////////////

VoronoiEdgeIterator::VoronoiEdgeIterator()
   : m_delaunay(nullptr), 
     veloop(nullptr), 
     veindex(0), 
     vecount(0) 
{
}


VoronoiEdgeIterator::VoronoiEdgeIterator(Delaunay* triangulator) 
{
   m_delaunay = triangulator;
   triangulateio* pvorout = (struct triangulateio*)triangulator->m_vorout;

   // TEST::: I hope so!
   Assert(triangulator->GetFirstIndexNumber() == 0, "");

   veloop = pvorout->edgelist; 
   veindex = 0; 
   vecount = pvorout->numberofedges;
}


VoronoiEdgeIterator VoronoiEdgeIterator::operator++() 
{
   VoronoiEdgeIterator veit;

   veit.veloop = veloop;
   veit.veindex = veindex;
   veit.m_delaunay = m_delaunay;

   // an edge is represented as 2 integer indexes!
   if (veindex / 2 + 1 < vecount ) 
   {
       veindex += 2;
   }
   else 
   {
      veindex = 0;
      veloop = nullptr;
   }

   Assert(veindex / 2 < vecount, "");
   return veit;
}


int VoronoiEdgeIterator::startPointId() const 
{
   if (!veloop) 
   {
      Assert(false, "");
      return -1;
   }

   auto edgelist = (int*)veloop;
   return edgelist[veindex];
}


int VoronoiEdgeIterator::endPointId(Delaunay::Point& normvec) const
{
   if (!veloop) 
   {
      Assert(false, "");
      return -1;
   }

   Assert(veindex / 2 < vecount, "");
   auto edgelist = (int*)veloop;
   int idx = edgelist[veindex + 1];
   
   if (idx == -1) 
   {
      triangulateio* pvorout = (struct triangulateio*)m_delaunay->m_vorout;
      auto normlist = pvorout->normlist;
            
      // normlist has same no. of elements as edgelist!
      normvec[0] = normlist[veindex];
      normvec[1] = normlist[veindex + 1];

      Assert(!(normvec[0] == 0.0 && normvec[1] == 0.0), "");
   }
   else 
   {
      normvec[0] = 0.0;
      normvec[1] = 0.0;
   }

   return idx;
}


const Delaunay::Point& VoronoiEdgeIterator::Org()
{
   auto pointId = startPointId();

   VoronoiVertexIterator vit = m_delaunay->vvbegin();
   vit.advance(pointId);
   return *vit;
}


Delaunay::Point VoronoiEdgeIterator::Dest(bool& finiteEdge)
{
   // OPEN TODO::: optimization --- use const& as return value!
   //  -> don't uderstand this anymore, needed????

   Delaunay::Point normvec;

   auto pointId = endPointId(normvec);
   finiteEdge = pointId != -1;

   if (pointId == -1)
   {
      Assert(normvec.sqr_length() != 0.0, "");
      return normvec;
   }
   else
   {
      Assert(normvec.sqr_length() == 0.0, "");

      VoronoiVertexIterator vit = m_delaunay->vvbegin(); 
      vit.advance(pointId);
      return *vit;
   }

}


bool operator==(VoronoiEdgeIterator const& lhs, VoronoiEdgeIterator const& rhs) 
{
   if (lhs.veloop == rhs.veloop && lhs.veindex == rhs.veindex) 
      return true;

   return false;
}


bool operator!=(VoronoiEdgeIterator const& lhs, VoronoiEdgeIterator const& rhs) 
{
   return !(lhs == rhs);
}


/////////////////////////////////
//
//  TriangulationMesh impl.
//
/////////////////////////////////

TriangulationMesh::TriangulationMesh(Delaunay* triangulator)
   : m_delaunay(triangulator)
{
}


int TriangulationMesh::Sym(FaceIterator const& fit, char i) const
{
   TP_MESH_PLOOP(fit);

   char oval = (char)ploop->orient;
   ploop->orient = i;

   trianglelooptype top;
   triangle ptr;  // Temporary variable used by sym() macro! 
   sym(*ploop, top);
   ploop->orient = oval;

   if (top.tri != tpmesh->dummytri)
   {
      vertex farvertex;
      apex(top, farvertex);
      return ((int*)farvertex)[tpmesh->vertexmarkindex];
   }

   return -1;
}


FaceIterator TriangulationMesh::Sym(FaceIterator const& fit) const
{
   FaceIterator retval;
   retval.m_delaunay = fit.m_delaunay;

   TP_MESH_PLOOP(fit);

   trianglelooptype top;
   triangle ptr;  // Temporary variable used by sym() macro! 
   sym(*ploop, top);

   if (top.tri != tpmesh->dummytri)
   {
      retval.floop.tri = top.tri;
      retval.floop.orient = top.orient;
      return retval;
   }

   retval.floop.tri = nullptr;
   retval.floop.orient = 0;
   return retval;
}


FaceIterator TriangulationMesh::locate(int vertexid)
{
   FaceIterator retval;
   retval.m_delaunay = this->m_delaunay;

   TP_MESH_WRAP_ITER();
   TP_BEHAVIOR_ITER();

   trianglelooptype horiz;  // temp. variables for locate() & sym() macros!
   triangle ptr;

   horiz.tri = tpmesh->dummytri;
   horiz.orient = 0;
   symself(horiz);

   double dv[2];
   dv[0] = m_delaunay->m_pointList[vertexid][0];
   dv[1] = m_delaunay->m_pointList[vertexid][1];

   // Search for a triangle containing `newvertex'
   int intersect = pTriangleWrap->locate(tpmesh, tpbehavior, dv, &horiz);
   Assert(intersect == Triwrap::ONVERTEX, "Something went wrong in point location");

   if (intersect != Triwrap::ONVERTEX)
   {
      // Not on vertex!
      std::cerr << "ERROR: Something went wrong in point location!\n";
      pTriangleWrap->triexit(1);
   }

   retval.floop.tri = horiz.tri;
   retval.floop.orient = horiz.orient;

   return retval;
}


FaceIterator TriangulationMesh::Lnext(FaceIterator const& fit)
{
   FaceIterator retval;
   retval.m_delaunay = m_delaunay;

   lnext(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

   return retval;
}


FaceIterator TriangulationMesh::Lprev(FaceIterator const& fit)
{
   FaceIterator retval;
   retval.m_delaunay = m_delaunay;

   lprev(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

   return retval;
}


FaceIterator TriangulationMesh::Onext(FaceIterator const& fit)
{
   triangle ptr;
   FaceIterator retval;
   retval.m_delaunay = m_delaunay;

   //cout << "Onext called:\n " 
   //	 << Org(fit) << "\t" << Dest(fit) << "\t" << Apex(fit) << "";

   onext(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

   // retval could be dummy!
   return retval;
}


FaceIterator TriangulationMesh::Oprev(FaceIterator const& fit)
{
   triangle ptr;
   FaceIterator retval;
   retval.m_delaunay = m_delaunay;

   oprev(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

   return retval;
}


void TriangulationMesh::trianglesAroundVertex(int vertexid, std::vector<int>& ivv)
{
   FaceIterator fit = locate(vertexid);
   ivv.clear();

   int start = fit.Dest();
   int linkn = fit.Apex();

   ivv.push_back(vertexid);
   ivv.push_back(start);
   ivv.push_back(linkn);

   FaceIterator nfit = fit;
   FaceIterator pnfit = fit; // follows nfit by one triangle

   while (linkn != start)
   {
      nfit = Onext(nfit);
      if (nfit.isGhost())
      {
         // Do another algorithm
         ivv.clear();

         // use oprev now...
         fit = pnfit;
         nfit = fit;

         start = fit.Apex();
         linkn = fit.Dest();

         ivv.push_back(vertexid);
         ivv.push_back(linkn);
         ivv.push_back(start);

         while (linkn != start)
         {
            nfit = Oprev(nfit);
            if (nfit.isGhost())
               return;
            int a = nfit.Org();
            int b = nfit.Dest();
            int c = nfit.Apex();
            ivv.push_back(a);
            ivv.push_back(b);
            ivv.push_back(c);
            linkn = nfit.Dest();
         }

         return;
      }

      pnfit = nfit;

      int a = nfit.Org();
      int b = nfit.Dest();
      int c = nfit.Apex();

      //cout << "Triangle: " << a << "\t"  << b << "\t"  << c << "\n";

      ivv.push_back(a);
      ivv.push_back(b);
      ivv.push_back(c);

      linkn = nfit.Apex();
   }
}


} // namespace tpp
